Hexedryne save/network format spec

[TOC]

# Binary format details

## Numbers
Number types are denoted by the following table:
Symbol      | C(++) type
------------|--------------
`u8`/`byte` | `uint8_t`
`i8`        | `int8_t`
`u16`       | `uint16_t`
`i16`       | `int16_t`
`u32`       | `uint32_t`
`u32`       | `int32_t`
`u64`       | `uint64_t`
`u64`       | `int64_t`
`f`         | `float` (32-bit)
`d`         | `double` (64-bit)
All specified formats are little-endian, and floats/doubles are IEEE 754.

## Varints
(`u`)`varint`s are variable-length integers, stored in a big-endian fashion, each byte's most significant bit indicating continuation, and the actual binary data in the lower 7 bits.
`uvarint`s are, are their name implies, unsigned. Their signed counterpart (`varint`s) are encoded using a zigzag encoding, that is, `n` is encoded as `(n << 1) ^ (n >> B-1)` where `B` is the original integer's bit length.
Their max bit length are specified by a suffix, e.g. `varint64` -- note therefore (`u`)`varint8` would be pointless.
In case it isn't specified, the `varint` can virtually be of any length, indicating a bitfield (e.g. for flag storage) rather than an actual integer.
Their names are shortened to, respectively

* `v16`, `v32`, and `v64` for signed varints
* `uv16`, `uv32`, and `uv64` for unsigned varints
* `v` for bit fields

They come from [Google's Protobuf](https://developers.google.com/protocol-buffers/docs/encoding) library.

## Vectors
Vectors can be of dimensions 2 to 4. They are simply stored member-by-member, in `<x><y>[z][w]` order, with the type determined by the prefix.
E.g. `fvec3` is a 3-dimensional vector stored as 3 consecutive 32-bit IEEE754 floating-point numbers.

## Strings
Strings are arrays of arbitrary binary data -- usually text, in which case the UTF-8 enoding is used.

* `string` = `uv32 length; byte data[length];`
* `sstring` (short string) = `u8 length; byte data[length];`
* `mstring` (medium string) = `u16 length; byte data[length];`
* `lstring` (long string) = `u32 length; byte data[length];`

## Arrays
Arrays are sequences of tightly-packed data of an unique type.

Their length as well as their type can be either hard-coded or determined from another variable.
They are denoted by:

*  *`type`*`[SIZE]`, e.g. `int[42]`
* *`type name`*`[SIZE]` when named

Where `type` is the `TypeID` (see below) of the data elements.

## Datrees
Datrees (*Data Trees*) are key/value maps able to hold a variety of data types bound to a `string` key.
```
uv32 entryCount;
struct DatreeEntry {
  string key;
  TypeID type;
  @type data;
} entries[entryCount];
```
Type is represented by `datree`, and a hint about a sole data type is given by writing `datree<type>` (this does not, however, replace each entry's `type` field, and any badly-formatted data encountered should be discarded/ignored).

## TypeIDs
A `TypeID` is a `uv16` defining a type, of all presented above. It is made of two parts (bitwise diagram):
```
15 14         7 6          0
 +-+----------+-+----------+
 |X|  XType   |0|  DType   |
 +-+----------+-+----------+
```
`DType` is the data type and `XType` the modifier. `X` is used internally by the `uv16`.
DType  | Type
-------|-----
0      | None (bogus)
1      | `u8`
2      | `i8`
3      | `u16`
4      | `i16`
5      | `u32`
6      | `i32`
7      | `u64`
8      | `i64`
9      | `f`
10     | `d`
11     | `v`
12     | `uv16`
13     | `v16`
14     | `uv32`
15     | `v32`
16     | `uv64`
17     | `v64`
18     | `datree`

XType  | Modifier
-------|---------
0      | None (impossible in the byte stream since we use an `uv16`)
1      | Array
2      | `vec2`
3      | `vec3`
4      | `vec4`

## Other ID/status tables
### Compression
ID | Compression algorithm
---|----------------------
0  | None
1  | LZFX
2  | LZO*
3  | zlib (DEFLATE)
4  | LZMA°
*: Unimplemented
°: Have a dictionary that can be relocated/shared

### Chunk status
ID | Status
---|-------
0  | Unemerged
1  | Needs re-emerging
2  | Emerged, unmodified
3  | Emerged, modified only by map updates
4  | Emerged, modified by non-player action (mobs, map update...)
5  | Emerged, modified by player action



# Save files
## Overall structure
Universes are stored in folders containing the worlds it is made of as well as other (meta)data files.

### Header
Type      | Name  | Value
---------:|:------|-----------------
`byte[8]` | `HDs` | `\x01HX\xEDNusv`
`u32`     | `Hui` | Universe ID
`u8`      | `Hst` | Save file type
`u64`     | `HTs` | [UNIX Timestamp](https://en.wikipedia.org/wiki/Unix_time) of last edit
`u32`     | `Hfv` | Save format version
`v`       | `Hfl` | Flags
`u8`      | `HDc` | XOR checksum of previous bytes, `0xAA` as starting byte
`u8`      | `HDe` | `\x02`

### Footer

Type      | Name  | Value
---------:|:------|-----------------
`uint64`  | `Fcs` | 64-bit FastHash checksum of all previous bytes
`byte[8]` | `FTs` | `euHX\xEDN\x04\x1C`

## Save file types
### Universe Root (`Hst = 0x00`)
```c++
mstring universeName;
mstring universeSubtitle;
datree<uint16> idMapping;
datree universeProps;
uint16 worldIDs[];
```

### World Root (`Hst = 0x01`)
```c++
mstring worldName;
mstring worldSubtitle;
datree worldProps;
uint16 areasIDs[];
```

### World Area (`Hst = 0x02`)
An Area equates to 8×8×8 = 512 Chunks, themselves storing 16×16×16 blocks each, resulting in a maximum of 2 097 152 blocks stored, 8 MB of (uncompressed) raw data if no extra buffers are added.

#### Chunk
```c++
struct Chunk {
  // This chunk's block info size
  uv32 size;
  if (size > 0) {
    uint8 compID; // Compression method
    v compFlags;
    compressed using @compID {
      uint16 ids[16*16*16]; // Block IDs
      uint16 data[16*16*16]; // Block data
      datree<?[16*16*16]> buffers; // See Bufferspecs section
      uint16 metadataCount;
      datree metadata[metadataCount];
    }
  } 
  // Entity data
  uv32 entityCount;
  struct Entity {
    uint64 id;
    fvec3 position; // Relative to the current Chunk's origin
    fvec3 velocity;
    datree properties;
  } entities[entityCount];
};
```
Block IDs and data are indexed in the flat array by `index = x + y*16 + z*16*16`.

Block data (let's call it `bdata`) matching the bitmask `0x8000`indicate a metadata pointer -- that is, said block has a metadata Datree stored in `metadata` at index `bdata & 0x7FFFF`. This Datree can contain arbitrarily-defined data (as mods please) about the block. It has a special entry called `__data` containing the block's actual `bdata` if it wasn't a metadata pointer and isn't zero, and is the value returned by functions getting the block's data.

#### Areas
```c++
uv32 areaCoordinates;
Chunk chunks[512];
```
Chunks are indexed in the flat array by `index = x + y*8 + z*8*8`.

# Bufferspecs
## Default bufferspecs
* `light8` -> `u8`
* `light555` -> `u16`
* `light8_8` -> `u8` + `u8`
* `light555_555` -> `u16` + `u16`
* `temperature` -> `f`
* `humidity` -> `f`
* `radiation` -> `f`
* `electricity` -> `f` (U, voltage) + `f` (I, electric current)

## Mod-defined bufferspecs
Registered by mods upon their load. Like block names, they are prefixed with the mod identifier, e.g. `gases:entropy`.

##Bufferspec Processors
* `lightspread`
  * `falloff`
  * TBD (2nd light computation)
* `equilibrium`
  * Params TBD (conductivity, ...)

# Network
## Messages
All network communication in Diggler is done via sequential messages, delivered by the [ENet library](http://enet.bespin.org) on multiple ENet channels.
### Message channels
Channel | Usage
--------|------
0       | Base
1       | Chat
2       | Life (player/entity spawn/death)
3       | Movement (player/entity movement)
4       | Metadata (Universe/World/entity metadata transfer)
5       | ChunkTransfer
6       | ChunkUpdate
